# 基本数据类型

### 0 原始类型

```
原始类型6种+复杂类型：Undefined、Null、Boolean、Number、String、Symbol(es6)，复杂类型:Object
检测原始类型：typeof
返回值：
	"undefined"
	"boolean"
	"number"
	"string"
	"object"  检测Null或者是Object
	"function"
	"symbol"
类型转换一般就5中类型：Undefined,Boolean,Number,String,Object
```

### 1 Undefined

```
当生命变量，但是没有赋值时，typeof结果就是undefined，但是对于未声明的对象，也会出现undefined的假象
let name;
console.log(typeof name) // undefined
console.log(typeof age) // undefined
if(name){} //不会执行
if(age){} // 会报错
```

### 2 Null

```
null跟undefined一样都是假值，undefined是null派生来的，所以undefined==null
let age;
let o=null;
if(o){} //不会执行
console.log(age==o) // true
```

### 3 Boolean

**将Boolean、Number和String进行类包装，每当用到某个原始值的方法或者属性时，后台都会创建一个相应的原始包装类型的对象，这个对象是临时的，用完以后就会销毁。**

```
Boolean类型转换，静态函数Boolean()
转化规则：
```

| 数据类型  |     转为true值     | 转为false值 |
| :-------- | :----------------: | ----------: |
| Undefined |         无         |   undefined |
| Number    |        非0         |    0或者NaN |
| String    |     非空字符串     |    空字符串 |
| Object    | 正常对象（包括{}） |        null |

##### 1 原始包装类

```
let falseObject = new Boolean(false)
let flag = falseObject && true //结果为true，因为falseObject为正常对象
```

### 4 Number

```
整数的浮点数会自动转为整数，例如1.0会自动转为1
```

##### 4.1 NaN

```
当除0以后，会出现NaN,所有包含NaN的操作结果都是NaN
判断NaN函数，静态函数isNaN(),接收所有类型，此时会先转为Number类型，在判断是不是NaN
```

##### 4.2 类型转化

```
Number() 接收所有类型
```

| 数据类型  | 转化规则                                          |
| --------- | ------------------------------------------------- |
| Undefined | NaN                                               |
| String    | ""为0，包含数字的转为数字，其他情况NaN,如:"11abc" |
| Boolean   | true为1，false为0                                 |
| Object    | null为0，其他调用valueOf()方法                    |

```
parseInt()和parseFloat()主要用于字符串转Number类型
parseInt("111abc") //111
parseInt("1.1")   //1
parseFloat("1.1abc")  //1.1
parseInt("abc123")  //NaN
parseInt("") //NaN
```

##### 4.3 原始包装类

```
num.toFixed()://用于指定小数点后面几位,四舍五入规则，使用0填充
Number.isInteger(num)//用于判断是否为整数
Number.isSafeInteger()//用于判断整数是否安全
```

### 5 String

##### 5.1 类型转换

```
转化为string类型
o.toString()方法，注意：null和undefined没有to.String()方法
String()方法可以解决null和undefined问题
```

| 数据类型  | 2           |
| --------- | ----------- |
| undefined | "undefined" |
| null      | "null"      |

##### 5.2 模板字面量

```
可换行定义字符串
let str=`first line
second line`
使用插值表达式
let number=5
let str = `${number} * ${number} = ${number*number}`
插值表达式里面的变量都会调用.toString()方法

模板字面量标签函数
let a=1
let b=2
function add(strings,...str){
    console.log(strings)	//[""," + "," = ",""]
    for(const item of str)	
        console.log(item)	//1 2 3
}
add`${a} + ${b} = ${a+b}`
```

##### 5.3 string包装类

**常用属性或者方法:**

```
str.length //返回字符串长度

str.charAt(num) // 返回指定位置的char
let message = "abcde"
message.charAt(2) //"c"

字符串拼接：
str.concat() 与 + 
let str = str.concat(str1,str2) // str本身是不会变得，所以需要重新赋值，使用+更方便

字符串中提取子字符串：
slice(),substr(),substring() //都不改变原字符串
let message = "hello world"
message.slice(3,7)
message.substring(3,7) //"lo w" 参数表示起始位置和终止位置，前闭后开
message.substr(3,7) //"lo worl" 第二个参数表示提取的个数
slice() 2个参数都可为负数，表示地址索引的位置，实现原理：将length+负数
substr()  第一个负数同上，第二个负数变为0
substring() 2个参数为负数时都会变成0，从0到第一个参数中间的字符串

字符串位置方法：用于在字符串中定位子字符串位置
indexOf()和lastIndexOf(),未找到，则返回-1
前者从开头开始找，后者从结尾开始找
遍历字串的所有位置：
let str="Lorem ipsum dolor sit amet, consectetur adipisicing elit"
let substr = "e"
let res=[]
let opsition = str.indexOf(substr)
while(opsition > -1){
    res.push(opsition)
    opsition = str.indexOf(substr,opsition+1)
} //[3,24,32,35,52]

字符串包含方法：用于判断字符串中是否有子字符串
str.startsWith(substr) //如果str是以substr开头，则返回true
str.endsWith(substr)  //如果str是以substr结尾，则返回true
str.includes(substr) //如果str中包含substr,则返回true

trim():返回删除前后空格的字符串
trimLeft()和trimRight()
let res = "  hello world  ".trim() // "hello world"

repeat(num):重复字符串
let res = "na ".repeat(2)   //"na na "

左右填充函数：padStart()和padEnd()
参数说明：第一个参数表示填充后的字符的总长，第二个表示要填充的字符，默认是空格
let str = "foo"
let res = str.padStart(6,"abc")  //abcfoo

字符串的迭代与解构
let message = "hello"
let iterator = message[Symbol.iterator]()
iterator.next() // {value:"h",done:flase}
或者：
for(const item of message){
	console.log(item) //"h" "e" "l" "l" "o"
}
[...message] ["h","e","l","l","o"]

字符串大小写转换：
toLowerCase()和toUpperCase()

字符串模式匹配方法：
match()方法:同exec()方法，只是使用的对象不一样
let text ="hello world"
let pattern = /hello/
let res = text.match(pattern)
或者
let res = pattern.exec(text)
search()方法:返回字符串中的位置
let text ="hello world"
let pattern = /llo/
let res = text.search(pattern) //2

replace()方法:2个参数，若第一个参数为字符串，则只会替换第一个符合条件的，若要全部替换，则第一个参数应该为正则表达式，第二个参数为替换规则，或者是替换的字符串
let text ="cat,bat,cat"
let res = text.replace("at","on") //"con,bat,cat"
let res = text.replace(/at/g,"on") //"con,bon,con"
第二个参数可以是一个函数，第一个参数是每次匹配到的字符串，后面2个参数不重要，第二个为pos，第三个为原字符串
function htmlEscape(text){
    return text.replace(/[<>"&]/g,(match,position,originalText)=>{
        switch(match){
            case "<":
                return "&lt;"
            case ">":
                return "&gt;"
            case "&":
                return "&amp;"
            case "\"":
                return "&quot;"
        }
    })
}
console.log(htmlEscape("<p class=\"greeting\">hello world!</p>"))
//&lt;p class=&quot;greeting&quot;&gt;hello world!&lt;/p&gt;

split()方法：根据传入的分隔符将字符串分割成数组
let text="abc,def,gs"
let res = text.split(",",2) //["abc","def"]  第二个参数限制了数组的长度

localeCompare()方法：比较2个字符串
如果前者大，通常返回1，如果一样大，则返回0，如果前者小，通常返回-1
let text = "hello"
let text1 = "world"
let res = text.localeCompare(text1) //1
```

### 6 Symbol

```
作用：确保对象属性使用唯一标识符，用作非字符串形式的对象属性
使用方法：不支持与new一起使用（构造函数使用）
let symbol1 = Symbol("symbol1")  //参数作为描述符
```

##### 6.1 全局符号注册表

```
作用就是全局注册，然后别处使用。
let s1 = Symbol.for("name")
let s2 = Symbol("name") //s1与S2没有关系
查询全局注册表：参数为符号
Symbol.keyFor(s1) //返回name
```

##### 6.2 使用符号作为属性

```
只能在计算属性语法中使用符号作为属性
let s=Symbol("foo")
let o={
	[s]:"foo value"
}
o[s]="foo value"
```

##### 6.3 属性查询函数

```
Object.getOwnPropertyNames(o) //返回常规属性数组  键
Object.getOwnPropertySymbols(o) //返回符号属性数组 键
Object.getOwnPropertyDescriptors(o) //返回所有属性数组 键值
Reflect.ownKeys(o) //返回所有属性数组 键
```

### 7 Object

```
Object实例共同属性和方法
constructor:指向构造函数
hasOwnProperty("name"):检测实例是否有name属性，但是不包括原型上面
isPrototypeof(object):判断当前对象是否为另一个对象的原型
propertyIsEnumerable("name"):判断name属性是否可以使用for-in
toLocaleString():
toString():
valueOf():这3个都是用于返回字符串形式

对象的属性，可以用数字命名，但是会自动转化为字符串
let person={
	0:"person"
}
访问：person["0"]
```

# 基本引用类型(原生引用类型)

### 1 Date

##### 0 Date与Date.parse()、Date.UTC()以及Date.now()

```
let now = new Date() //返回的是当前日期 2020-12-25T17:11:12.766Z
若要返回其他日期，需要传入日期的毫秒数
Date.parse()和Date.UTC()函数用于构造毫秒
Date.parse() 支持的格式：
“月/日/年”  “5/23/2019”
"月名 日，年"   “May 23,2019”
"周几 月名 日 年 时：分：秒 时区"	"Tue May 23 2019 00:00:00 GMT-0700"
let time = new Date(Date.parse("May 23,2019"))
或者：let time = new Date("May 23,2019")

Date.UTC()支持的格式：
年，零起点月份，日，时，分，秒，毫秒，只有前两个是必须的，其他都是默认从第一个开始
let time = new Date(Date.UTC(2005,4,5,17,55,55))
或者：let time = new Date(2005,4,5,17,55,55)

Date.now()返回执行时的时间（毫秒）
let start = Date.now()
doSomething()
let end = Date.now()
let time = end - start
```

##### 1 继承的方法

```
toLocaleString()和toString()返回字符串形式
valueOf()返回毫秒数，Number类型
其他获取年月日的方法请参考书P106页
```

### 2 RegExp

##### 1 正则的基本使用

```
定义规则:
let expression = /pattern/flags

如：
let pattern1 = /[bc]at/i
或者使用构造函数：
let pattern2 = new RegExp("[bc]at","i")  //2个参数都是字符串

使用：
let match1 = pattern1.exec("bat")
let match2 = pattern2.exec("cat")

元字符转义：
let pattern1 = /\[abc\]/
在构造函数模式中所有元字符都需要转义，包括转义字符：
let pattern2 = new RegExp("\\[abc\\]")
尤其注意：
\abc,转义\需要4个\
let pattern1 = /\\abc/
let pattern2 = new RegExp("\\\\abc")
```

##### 2 flags

flags包括：

| flag | 含义                                             | RegExp实例查询属性 |
| ---- | ------------------------------------------------ | ------------------ |
| g    | 查找全部内容，不会找到一个以后就停止             | global             |
| i    | 不区分大小写                                     | ignoreCase         |
| m    | 多行模式                                         | multiline          |
| y    | 粘附模式，表示只查找lastIndex以后的字符串        | sticky             |
| u    | Unicode模式                                      | unicode            |
| s    | dotAll模式，表示元字符.匹配任何字符（包括\n \r） | dotAll             |

此外还有其他属性：

| 属性      | 解释                                       |
| --------- | ------------------------------------------ |
| lastIndex | 下一次搜索的开始位置                       |
| source    | 表达式的字面量字符串，没有开头和结尾的斜杠 |
| flags     | 查询flags，没有斜杠                        |

##### 3 实例方法

```
返回值:Array类型，或者是null。额外包括2个属性，index和input，返回值第一个是匹配整个的字符串，后续的是捕获组匹配的字符串，也就是()里面的内容
let text = "mom and dad and baby"
let pattern = /mom (and dad (and baby)?)?/gi;
let matches = pattern.exec(text)
console.log(matches.index) //在text中的开始索引
console.log(matches.input) //原始text的值
console.log(matches[0])		//整个匹配
console.log(matches[1])		//捕获组匹配
console.log(matches[2])
```

test方法

```
用于测试text的值与模式是否可匹配，通常用于查验输入格式，如：
let text = "000-00-0000"
let pattern = /\d{3}-\d{2}-\d{4}/
if(pattern.text()){
	doSomething()
}
```

toString和toLocaleString方法

```
都返回字面量形式，带反斜杠和flags
```

##### 4 RegExp静态方法

```
主要用于检测最后一次匹配的模式、匹配的结果等
```

##### 5 正则匹配规则

let text="cat,bat,dat"

| 符号 | 含义                                 | 举例                                         |
| ---- | ------------------------------------ | -------------------------------------------- |
| ()   | 捕获组，一个捕获组只能捕获一个结果。 | pattern=/(.at)/<br />res[0]="cat",res[1]=cat |
| []   | 表示[]中选一个                       | pattern = /[ab]at/<br />res[0]="bat"         |

### 3 Global

##### 3.1 URL编码方法

```
let uri = "http://www.wrox.com/ value.js#start"
let res = encodeURI(uri) //只会对空格进行编码，变为%20
		= encodeURIComponent(uri) //会对所有特殊字符进行编码
解码： decodeURI(res)
	decodeURIComponent(res)
```

##### 3.2 eval()方法

```
输入字符串，然后将字符串当作语句执行
eval("console.log('hi')")
相当于：console.log("hi")
```

##### 3.4 window对象

```
window对象是Global对象的代理
```

### 4 Math

```
Math.random()//返回[0,1)的小数
let num = Math.floor(Math.random()*10+1) //[1,10]
```



# 集合引用类型

### 1 Array

##### 1.1 创建数组

```
构造函数方法，其中new可省
let arr = new Array()
let arr = new Array(20) //20表示数组长度
let arr = new Array("red","green")
字面量方法
let arr = []
let arr = ["red",green]

静态方法 from()和of()：用于将其他类型转化为Array
Array.from("matt") //["m","a","t"],用于将可迭代对象转化为Array
当传入值为数组时，将进行复制，不过是浅复制，对于数组中的引用类型，只会复制引用的地址
Array.from()可以把自定义属性变成Array
let o = {
    0:0,
    "1":2,
    length:2
}
console.log(o)
let a = Array.from(o)
console.log(a)
Array.from()可接收第2个参数，作为处理函数
Array.from(arr1,x=>x+1) //arr1=[1,2] res=[2,3]
Array.of(a1,a2)//[a1,a2]，of方法将传入的参数作为数组的项进行构造，用的不多。
```



