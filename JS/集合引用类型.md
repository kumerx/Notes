# 基本数据类型

### 0 原始类型

```
原始类型6种+复杂类型：Undefined、Null、Boolean、Number、String、Symbol(es6)，复杂类型:Object
检测原始类型：typeof
返回值：
	"undefined"
	"boolean"
	"number"
	"string"
	"object"  检测Null或者是Object
	"function"
	"symbol"
类型转换一般就5中类型：Undefined,Boolean,Number,String,Object
```

### 1 Undefined

```
当生命变量，但是没有赋值时，typeof结果就是undefined，但是对于未声明的对象，也会出现undefined的假象
let name;
console.log(typeof name) // undefined
console.log(typeof age) // undefined
if(name){} //不会执行
if(age){} // 会报错
```

### 2 Null

```
null跟undefined一样都是假值，undefined是null派生来的，所以undefined==null
let age;
let o=null;
if(o){} //不会执行
console.log(age==o) // true
```

### 3 Boolean

**将Boolean、Number和String进行类包装，每当用到某个原始值的方法或者属性时，后台都会创建一个相应的原始包装类型的对象，这个对象是临时的，用完以后就会销毁。**

```
Boolean类型转换，静态函数Boolean()
转化规则：
```

| 数据类型  |     转为true值     | 转为false值 |
| :-------- | :----------------: | ----------: |
| Undefined |         无         |   undefined |
| Number    |        非0         |    0或者NaN |
| String    |     非空字符串     |    空字符串 |
| Object    | 正常对象（包括{}） |        null |

##### 1 原始包装类

```
let falseObject = new Boolean(false)
let flag = falseObject && true //结果为true，因为falseObject为正常对象
```

### 4 Number

```
整数的浮点数会自动转为整数，例如1.0会自动转为1
```

##### 4.1 NaN

```
当除0以后，会出现NaN,所有包含NaN的操作结果都是NaN
判断NaN函数，静态函数isNaN(),接收所有类型，此时会先转为Number类型，在判断是不是NaN
```

##### 4.2 类型转化

```
Number() 接收所有类型
```

| 数据类型  | 转化规则                                          |
| --------- | ------------------------------------------------- |
| Undefined | NaN                                               |
| String    | ""为0，包含数字的转为数字，其他情况NaN,如:"11abc" |
| Boolean   | true为1，false为0                                 |
| Object    | null为0，其他调用valueOf()方法                    |

```
parseInt()和parseFloat()主要用于字符串转Number类型
parseInt("111abc") //111
parseInt("1.1")   //1
parseFloat("1.1abc")  //1.1
parseInt("abc123")  //NaN
parseInt("") //NaN
```

##### 4.3 原始包装类

```
num.toFixed()://用于指定小数点后面几位,四舍五入规则，使用0填充
Number.isInteger(num)//用于判断是否为整数
Number.isSafeInteger()//用于判断整数是否安全
```

### 5 String

##### 5.1 类型转换

```
转化为string类型
o.toString()方法，注意：null和undefined没有to.String()方法
String()方法可以解决null和undefined问题
```

| 数据类型  | 2           |
| --------- | ----------- |
| undefined | "undefined" |
| null      | "null"      |

##### 5.2 模板字面量

```
可换行定义字符串
let str=`first line
second line`
使用插值表达式
let number=5
let str = `${number} * ${number} = ${number*number}`
插值表达式里面的变量都会调用.toString()方法

模板字面量标签函数
let a=1
let b=2
function add(strings,...str){
    console.log(strings)	//[""," + "," = ",""]
    for(const item of str)	
        console.log(item)	//1 2 3
}
add`${a} + ${b} = ${a+b}`
```

##### 5.3 string包装类

**常用属性或者方法:**

```
str.length //返回字符串长度

str.charAt(num) // 返回指定位置的char
let message = "abcde"
message.charAt(2) //"c"

字符串拼接：
str.concat() 与 + 
let str = str.concat(str1,str2) // str本身是不会变得，所以需要重新赋值，使用+更方便

字符串中提取子字符串：
slice(),substr(),substring() //都不改变原字符串
let message = "hello world"
message.slice(3,7)
message.substring(3,7) //"lo w" 参数表示起始位置和终止位置，前闭后开
message.substr(3,7) //"lo worl" 第二个参数表示提取的个数
slice() 2个参数都可为负数，表示地址索引的位置，实现原理：将length+负数
substr()  第一个负数同上，第二个负数变为0
substring() 2个参数为负数时都会变成0，从0到第一个参数中间的字符串

字符串位置方法：用于在字符串中定位子字符串位置
indexOf()和lastIndexOf(),未找到，则返回-1
前者从开头开始找，后者从结尾开始找
遍历字串的所有位置：
let str="Lorem ipsum dolor sit amet, consectetur adipisicing elit"
let substr = "e"
let res=[]
let opsition = str.indexOf(substr)
while(opsition > -1){
    res.push(opsition)
    opsition = str.indexOf(substr,opsition+1)
} //[3,24,32,35,52]

字符串包含方法：用于判断字符串中是否有子字符串
str.startsWith(substr) //如果str是以substr开头，则返回true
str.endsWith(substr)  //如果str是以substr结尾，则返回true
str.includes(substr) //如果str中包含substr,则返回true

trim():返回删除前后空格的字符串
trimLeft()和trimRight()
let res = "  hello world  ".trim() // "hello world"

repeat(num):重复字符串
let res = "na ".repeat(2)   //"na na "

左右填充函数：padStart()和padEnd()
参数说明：第一个参数表示填充后的字符的总长，第二个表示要填充的字符，默认是空格
let str = "foo"
let res = str.padStart(6,"abc")  //abcfoo

字符串的迭代与解构
let message = "hello"
let iterator = message[Symbol.iterator]()
iterator.next() // {value:"h",done:flase}
或者：
for(const item of message){
	console.log(item) //"h" "e" "l" "l" "o"
}
[...message] ["h","e","l","l","o"]

字符串大小写转换：
toLowerCase()和toUpperCase()

字符串模式匹配方法：
match()方法:同exec()方法，只是使用的对象不一样
let text ="hello world"
let pattern = /hello/
let res = text.match(pattern)
或者
let res = pattern.exec(text)
search()方法:返回字符串中的位置
let text ="hello world"
let pattern = /llo/
let res = text.search(pattern) //2

replace()方法:2个参数，若第一个参数为字符串，则只会替换第一个符合条件的，若要全部替换，则第一个参数应该为正则表达式，第二个参数为替换规则，或者是替换的字符串
let text ="cat,bat,cat"
let res = text.replace("at","on") //"con,bat,cat"
let res = text.replace(/at/g,"on") //"con,bon,con"
第二个参数可以是一个函数，第一个参数是每次匹配到的字符串，后面2个参数不重要，第二个为pos，第三个为原字符串
function htmlEscape(text){
    return text.replace(/[<>"&]/g,(match,position,originalText)=>{
        switch(match){
            case "<":
                return "&lt;"
            case ">":
                return "&gt;"
            case "&":
                return "&amp;"
            case "\"":
                return "&quot;"
        }
    })
}
console.log(htmlEscape("<p class=\"greeting\">hello world!</p>"))
//&lt;p class=&quot;greeting&quot;&gt;hello world!&lt;/p&gt;

split()方法：根据传入的分隔符将字符串分割成数组
let text="abc,def,gs"
let res = text.split(",",2) //["abc","def"]  第二个参数限制了数组的长度

localeCompare()方法：比较2个字符串
如果前者大，通常返回1，如果一样大，则返回0，如果前者小，通常返回-1
let text = "hello"
let text1 = "world"
let res = text.localeCompare(text1) //1
```

### 6 Symbol

```
作用：确保对象属性使用唯一标识符，用作非字符串形式的对象属性
使用方法：不支持与new一起使用（构造函数使用）
let symbol1 = Symbol("symbol1")  //参数作为描述符
```

##### 6.1 全局符号注册表

```
作用就是全局注册，然后别处使用。
let s1 = Symbol.for("name")
let s2 = Symbol("name") //s1与S2没有关系
查询全局注册表：参数为符号
Symbol.keyFor(s1) //返回name
```

##### 6.2 使用符号作为属性

```
只能在计算属性语法中使用符号作为属性
let s=Symbol("foo")
let o={
	[s]:"foo value"
}
o[s]="foo value"
```

##### 6.3 属性查询函数

```
Object.getOwnPropertyNames(o) //返回常规属性数组  键
Object.getOwnPropertySymbols(o) //返回符号属性数组 键
Object.getOwnPropertyDescriptors(o) //返回所有属性数组 键值
Reflect.ownKeys(o) //返回所有属性数组 键
```

### 7 Object

```
Object实例共同属性和方法
constructor:指向构造函数
hasOwnProperty("name"):检测实例是否有name属性，但是不包括原型上面
isPrototypeof(object):判断当前对象是否为另一个对象的原型
propertyIsEnumerable("name"):判断name属性是否可以使用for-in
toLocaleString():
toString():
valueOf():这3个都是用于返回字符串形式

对象的属性，可以用数字命名，但是会自动转化为字符串
let person={
	0:"person"
}
访问：person["0"]
```

# 基本引用类型(原生引用类型)

### 1 Date

##### 0 Date与Date.parse()、Date.UTC()以及Date.now()

```
let now = new Date() //返回的是当前日期 2020-12-25T17:11:12.766Z
若要返回其他日期，需要传入日期的毫秒数
Date.parse()和Date.UTC()函数用于构造毫秒
Date.parse() 支持的格式：
“月/日/年”  “5/23/2019”
"月名 日，年"   “May 23,2019”
"周几 月名 日 年 时：分：秒 时区"	"Tue May 23 2019 00:00:00 GMT-0700"
let time = new Date(Date.parse("May 23,2019"))
或者：let time = new Date("May 23,2019")

Date.UTC()支持的格式：
年，零起点月份，日，时，分，秒，毫秒，只有前两个是必须的，其他都是默认从第一个开始
let time = new Date(Date.UTC(2005,4,5,17,55,55))
或者：let time = new Date(2005,4,5,17,55,55)

Date.now()返回执行时的时间（毫秒）
let start = Date.now()
doSomething()
let end = Date.now()
let time = end - start
```

##### 1 继承的方法

```
toLocaleString()和toString()返回字符串形式
valueOf()返回毫秒数，Number类型
其他获取年月日的方法请参考书P106页
```

### 2 RegExp

##### 1 正则的基本使用

```
定义规则:
let expression = /pattern/flags

如：
let pattern1 = /[bc]at/i
或者使用构造函数：
let pattern2 = new RegExp("[bc]at","i")  //2个参数都是字符串

使用：
let match1 = pattern1.exec("bat")
let match2 = pattern2.exec("cat")

元字符转义：
let pattern1 = /\[abc\]/
在构造函数模式中所有元字符都需要转义，包括转义字符：
let pattern2 = new RegExp("\\[abc\\]")
尤其注意：
\abc,转义\需要4个\
let pattern1 = /\\abc/
let pattern2 = new RegExp("\\\\abc")
```

##### 2 flags

flags包括：

| flag | 含义                                             | RegExp实例查询属性 |
| ---- | ------------------------------------------------ | ------------------ |
| g    | 查找全部内容，不会找到一个以后就停止             | global             |
| i    | 不区分大小写                                     | ignoreCase         |
| m    | 多行模式                                         | multiline          |
| y    | 粘附模式，表示只查找lastIndex以后的字符串        | sticky             |
| u    | Unicode模式                                      | unicode            |
| s    | dotAll模式，表示元字符.匹配任何字符（包括\n \r） | dotAll             |

此外还有其他属性：

| 属性      | 解释                                       |
| --------- | ------------------------------------------ |
| lastIndex | 下一次搜索的开始位置                       |
| source    | 表达式的字面量字符串，没有开头和结尾的斜杠 |
| flags     | 查询flags，没有斜杠                        |

##### 3 实例方法

```
返回值:Array类型，或者是null。额外包括2个属性，index和input，返回值第一个是匹配整个的字符串，后续的是捕获组匹配的字符串，也就是()里面的内容
let text = "mom and dad and baby"
let pattern = /mom (and dad (and baby)?)?/gi;
let matches = pattern.exec(text)
console.log(matches.index) //在text中的开始索引
console.log(matches.input) //原始text的值
console.log(matches[0])		//整个匹配
console.log(matches[1])		//捕获组匹配
console.log(matches[2])
```

test方法

```
用于测试text的值与模式是否可匹配，通常用于查验输入格式，如：
let text = "000-00-0000"
let pattern = /\d{3}-\d{2}-\d{4}/
if(pattern.text()){
	doSomething()
}
```

toString和toLocaleString方法

```
都返回字面量形式，带反斜杠和flags
```

##### 4 RegExp静态方法

```
主要用于检测最后一次匹配的模式、匹配的结果等
```

##### 5 正则匹配规则

let text="cat,bat,dat"

| 符号 | 含义                                 | 举例                                         |
| ---- | ------------------------------------ | -------------------------------------------- |
| ()   | 捕获组，一个捕获组只能捕获一个结果。 | pattern=/(.at)/<br />res[0]="cat",res[1]=cat |
| []   | 表示[]中选一个                       | pattern = /[ab]at/<br />res[0]="bat"         |

### 3 Global

##### 3.1 URL编码方法

```
let uri = "http://www.wrox.com/ value.js#start"
let res = encodeURI(uri) //只会对空格进行编码，变为%20
		= encodeURIComponent(uri) //会对所有特殊字符进行编码
解码： decodeURI(res)
	decodeURIComponent(res)
```

##### 3.2 eval()方法

```
输入字符串，然后将字符串当作语句执行
eval("console.log('hi')")
相当于：console.log("hi")
```

##### 3.4 window对象

```
window对象是Global对象的代理
```

### 4 Math

```
Math.random()//返回[0,1)的小数
let num = Math.floor(Math.random()*10+1) //[1,10]
```



# 集合引用类型

### 1 Array

##### 1.1 创建数组

```
构造函数方法，其中new可省
let arr = new Array()
let arr = new Array(20) //20表示数组长度
let arr = new Array("red","green")
字面量方法
let arr = []
let arr = ["red",green]

静态方法 from()和of()：用于将其他类型转化为Array
Array.from("matt") //["m","a","t"],用于将可迭代对象转化为Array
当传入值为数组时，将进行复制，不过是浅复制，对于数组中的引用类型，只会复制引用的地址
Array.from()可以把自定义属性变成Array
let o = {
    0:0,
    "1":2,
    length:2
}
console.log(o)
let a = Array.from(o)
console.log(a)
Array.from()可接收第2个参数，作为处理函数
Array.from(arr1,x=>x+1) //arr1=[1,2] res=[2,3]
Array.of(a1,a2)//[a1,a2]，of方法将传入的参数作为数组的项进行构造，用的不多。

length属性：并不是可读的，可以动态更改
let arr = ["red"]
arr.length=100 //那么1-99都会用undefined来替代

检测数组：
1 arr instanceof Array
2 Array.isArray(arr)

迭代器方法：keys(),values(),entries()
let arr = ["red","yellow","green"]
let res = arr.keys()  //0,1,2  索引的迭代器
let res = arr.values()//"red","yellow","green"  数组元素的迭代器
let res = arr.entries() //[0,"red"],[1,"yellow"],[2,"green"] 键值对的迭代器，最好都用 Array.from()方法转成数组
解构：
for(const [idx,element] of arr.entries()){}

复制和填充方法：fill()和copyWithin()
let arr = new Array(10)
arr.fill(0,0,arr.length)  //用0填充[0,arr.length)的元素，后面2个参数可以不要
copyWithin()是将数组中部分数据插到数组中指定位置。3个参数，要插入的位置，插入的起始地址和中止地址
let arr = [0,1,2,3,4,5,6,7,8,9]
arr.copyWithin(2,0,6) //[0,1,0,1,2,3,4,5,8,9]

数组转化为字符串：
toString()或者是valueOf()方法都返回字符串形式，以,分割
或者join("|"),指定分隔符，默认也是,

栈方法：
push()和pop()

队列方法:
push()和shift()  前面出
反向队列：unshift()和pop()

排序方法:sort()和reverse()
sort()可接受一个排序规则函数，若返回-1，则不变，返回整数，则交换，所以(a,b)=>a-b 这个正序

操作方法：
concat():把传入的参数或者是数组合并到当前数组，但是当前数组不会改变
let arr = ["red","yellow"]
let res = arr.concat("green",["grey","blue"]) //arr不变，res=["red","yellow","green","grey","blue"]
如果设置数组的Symbol.isConcatSpreadable = flase，那么合并的时候不会打平
let arr = ["red"]
let arr1 = ["green"]
arr1[Symbol.isConcatSpreadable] = flase
let res =arr.concat(arr1) //["red",["green"]]

slice()和splice()方法
slice()方法主要返回部分元素，不改变原来数组
slice(startIndex,endIndex) //返回对应的元素，还是前闭后开
splice()方法可用于删除、插入和替换，改变原来的数组
let arr = [1,2,3,4,5,6]
删除：要删除元素的索引和删除的数量
let res = arr.splice(1,2) //删除2和3 2个元素，返回被删除的元素
插入：要插入的位置，0，要插入的元素
let res = arr.splice(0,0,0) //在0位置插入0 没有返回值
替换：删除的位置，1，后续替换的元素
let res = arr.splice(0,1,1) //将0位置的0删除，替换成1

搜索和位置方法：
严格相等：indexOf(),lastIndexOf(),includes() 需要注意的是，查找的时候用的是 === 
前2个函数参数包括：要查找的项，开始查找的位置，返回-1或者确切的索引，最后一个返回boolean值
断言函数：find()和findIndex()
参数:(element,index,arr)=>判断函数,arr是原始数组，find()返回某一项，findIndex()返回索引值，如果找到第一个符合条件的，就不会再找下去

迭代方法：5个方法，第一个参数都是一个判断的函数，返回值将会不同。但是都不改变原始数组
every():如果都满足，则返回true
some():如果有一项满足，则返回true
filter():返回满足条件组成的数组
forEach():对每一项进行处理，但是没有返回值
map():对每一项都进行处理，有返回值
结论：map()更适合对数组进行改变，而forEach()更适合做遍历

归并方法：reduce()和reduceRight()，接受2个参数，第一个参数为处理函数，第二个参数为起始数，如果没有第二个参数，那么将从第二项开始，并且有返回值
let arr = [1,2,3,4,5]
let res = arr.reduce((pre,cur,index,arr)=>pre+cur) //15
recudeRight()从右开始往左边遍历
```

### 2 定型数组

```
ArrayBuffer,内存空间中动态申请的一段内存，学习WebGL的时候需要再看，详情请看书P155
```

### 3 Map

### 5 Set

# 迭代器与生成器

### 1 迭代器

```
迭代器属性：Symbol.iterator
迭代器生成：
let str = "hello world"
let iterator = str[Symbol.iterator]()
每个迭代器都是单独的，用一个对象生成的多个迭代器也是不同的
使用：iterator.next() //{value:"h",done:flase}

可迭代对象可使用下列方法：
for-of
数组解构  //[a,b,c] = arr
扩展操作符 //[...arr]
Array.from()等

当for-of等需要提前结束时，将会调用return()方法，返回IteratorResult对象
class Counter{
    constructor(limit){
        this.limit=limit
    }
    [Symbol.iterator](){
        let counter = 1;
        let limit = this.limit;
        return {
            next(){
            if(counter < limit){
                return {
                    value:counter++,
                    done:false
                }
            }else{
                return {
                    value:undefined,
                    done:true
                }
            }
        },
        return(){
            console.log("Exiting early")
            return {done:true}
        }
    }
    }
}
let o = new Counter(4)
for(const i of o){
    if(i>2){
        break;
    }else{
        console.log(i)
    }
}
return()方法是可选的，如果有，就可以提前结束，如果没有，就不能提前结束；但是有些可迭代是不能提前结束的，比如Array
```

### 2 生成器

##### 2.1 生成器基础

```

```



